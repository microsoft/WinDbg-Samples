//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
/*++

 THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
 ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 PARTICULAR PURPOSE.


Module Name:

    eXdi3.idl : IDL source for eXdi v3 interface

Abstract:

    This file will be processed by the MIDL tool to
    produce the type library and marshalling code.

    eXDI: eXtended Debug Interface.
    The interfaces described here are meant to be used for communication between an external debug driver 
    (like driver for Hardware Debug probe).


Author:

    Greg Hogdal 11-Nov-1999
    Ivan Shcherbakov (ivshcher) 31-Oct-2013

Environment:

    Win32 NT

--*/


import "oaidl.idl";
import "ocidl.idl";


#pragma region Summary of interfaces

// Standard interfaces
interface IeXdiServer3;
// This interface is the main server side eXDI interface. It provides access to the eXDI driver from any clients for anything except the CPU registers.

interface IeXdiClientNotifyRunChg3;
// This interface is a client side eXDI interface, to enable call backs for run state change notifications from the eXDI driver to any client that wishes it.
// It contains the following methods:


// QI'ed interfaces (from IeXdiServer)
interface IeXdiX86Context3;
// This interface is a server side eXDI interface, providing access to the eXDI driver for x86 CPU registers.

interface IeXdiX86ExContext3;
// This interface is a server side eXDI interface, providing access to the eXDI driver for extended x86 CPU registers ver 1.1 (Used by NT Windbg but not by CE Platform Builder),

interface IeXdiARM4Context3;
// This interface is a server side eXDI interface, providing access to the eXDI driver for ARM CPU registers ver 4.0.
// It includes all the VFPv3/Neon registers (D0..D31)

interface IeXdiArmV8Arch64Context3;
// This interface is a server side eXDI interface, providing access to the eXDI driver for ARMv8 (64-bit) CPU registers.

interface IeXdiX86_64Context3;
// This interface is a server side eXDI interface, providing access to the eXDI driver for X86_64 CPU registers.

interface IeXdiIA64Context3;
// This interface is a server side eXDI interface, providing access to the eXDI driver for IA64 CPU registers.


// Other interfaces
interface IeXdiCodeBreakpoint3;
// This interface gives access to eXDI driver generated Code BP objects.

interface IeXdiDataBreakpoint3;
// This interface gives access to eXDI driver generated Data BP objects.

interface IeXdiKeepaliveInterface3; //Used to check connection between debugging engine and the server

#pragma endregion

#pragma region Error codes

cpp_quote("// Common eXDI HRESULT values:")
cpp_quote("//")
cpp_quote("#define FACILITY_EXDI3   (0x87)")
cpp_quote("#define CUSTOMER_FLAG   (1)")
cpp_quote("//")
cpp_quote("#define SEV_SUCCESS         (0)")
cpp_quote("#define SEV_INFORMATIONAL   (1)")
cpp_quote("#define SEV_WARNING         (2)")
cpp_quote("#define SEV_ERROR           (3)")
cpp_quote("//")
cpp_quote("#define MAKE_EXDI3_ERROR(ErrorCode,Severity) ((HRESULT)(ErrorCode) | (FACILITY_EXDI3 << 16) | (CUSTOMER_FLAG << 29) | (Severity << 30))")
cpp_quote("//")
cpp_quote("//      S_OK                         (0)                                          // Operation successful")
cpp_quote("#define EXDI3_E_NOTIMPL               MAKE_EXDI3_ERROR (0x4001, SEV_ERROR)          // Not implemented (in the specific conditions - could be implement for others - like Kernel Debugger inactive)")
cpp_quote("#define EXDI3_E_OUTOFMEMORY           MAKE_EXDI3_ERROR (0x000E, SEV_ERROR)          // Failed to allocate necessary memory")
cpp_quote("#define EXDI3_E_INVALIDARG            MAKE_EXDI3_ERROR (0x0057, SEV_ERROR)          // One or more arguments are invalid")
cpp_quote("#define EXDI3_E_ABORT                 MAKE_EXDI3_ERROR (0x4004, SEV_ERROR)          // Operation aborted")
cpp_quote("#define EXDI3_E_FAIL                  MAKE_EXDI3_ERROR (0x4005, SEV_ERROR)          // Unspecified failure")
cpp_quote("#define EXDI3_E_COMMUNICATION         MAKE_EXDI3_ERROR (0x0001, SEV_ERROR)          // Communication error between host driver and target")
cpp_quote("//")
cpp_quote("#define EXDI3_E_NOLASTEXCEPTION       MAKE_EXDI3_ERROR (0x0002, SEV_ERROR)          // No exception occured already, cannot return last")
cpp_quote("#define EXDI3_I_TGTALREADYRUNNING     MAKE_EXDI3_ERROR (0x0003, SEV_INFORMATIONAL)  // Indicates that the target was already running")
cpp_quote("#define EXDI3_I_TGTALREADYHALTED      MAKE_EXDI3_ERROR (0x0004, SEV_INFORMATIONAL)  // Indicates that the target was already halted")
cpp_quote("#define EXDI3_E_TGTWASNOTHALTED       MAKE_EXDI3_ERROR (0x0005, SEV_ERROR)          // The target was not halted (before Single Step command issued)")
cpp_quote("#define EXDI3_E_NORESAVAILABLE        MAKE_EXDI3_ERROR (0x0006, SEV_ERROR)          // No resource available, cannot instantiate Breakpoint (in the kind requested)")
cpp_quote("#define EXDI3_E_NOREBOOTAVAIL         MAKE_EXDI3_ERROR (0x0007, SEV_ERROR)          // The external reset is not available programatically to the probe")
cpp_quote("#define EXDI3_E_ACCESSVIOLATION       MAKE_EXDI3_ERROR (0x0008, SEV_ERROR)          // Access violation on at least one element in address range specificified by the operation")
cpp_quote("#define EXDI3_E_CANNOTWHILETGTRUNNING MAKE_EXDI3_ERROR (0x0009, SEV_ERROR)          // Cannot proceed while target running. Operation not supported on the fly. Must halt the target first")
cpp_quote("#define EXDI3_E_USEDBYCONCURRENTTHREAD MAKE_EXDI3_ERROR (0x000A, SEV_ERROR)         // Cannot proceed immediately because resource is already used by concurrent thread. Recall later or call SetWaitOnConcurrentUse (TRUE) - default")
cpp_quote("#define EXDI3_E_ADVISELIMIT           MAKE_EXDI3_ERROR (0x000D, SEV_ERROR)          // The connection point has already reached its limit of connections and cannot accept any more")
//                                                               0x000E is used by EXDI3_E_OUTOFMEMORY


// From definition in winerror.h

//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+

//  where
//      Sev - is the severity code
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//      C - is the Customer code flag
//      R - is a reserved bit
//      Facility - is the facility code
//      Code - is the facility's status code

// Already define the facility codes

// FACILITY_WINDOWS                 8
// FACILITY_STORAGE                 3
// FACILITY_SSPI                    9
// FACILITY_SETUPAPI                15
// FACILITY_RPC                     1
// FACILITY_WIN32                   7
// FACILITY_CONTROL                 10
// FACILITY_NULL                    0
// FACILITY_MSMQ                    14
// FACILITY_MEDIASERVER             13
// FACILITY_INTERNET                12
// FACILITY_ITF                     4
// FACILITY_DISPATCH                2
// FACILITY_CERT                    11

#pragma endregion

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiServer
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#pragma region Common structures

/////////////////////////////////////////////////////////////////////////////
// Run Control section of the Interface
/////////////////////////////////////////////////////////////////////////////


typedef __int64 ADDRESS_TYPE, *PADDRESS_TYPE;

typedef unsigned __int64 DWORD64, *PDWORD64;


// Used by field TargetProcessorFamily in GLOBAL_TARGET_INFO_STRUCT. This info is the strict necessary to enable the debugger to identify completely the target.
const DWORD PROCESSOR_FAMILY_X86 = 0;
//const DWORD PROCESSOR_FAMILY_SH3 = 1;
//const DWORD PROCESSOR_FAMILY_SH4 = 2;
//const DWORD PROCESSOR_FAMILY_MIPS = 3;
const DWORD PROCESSOR_FAMILY_ARM = 4;
const DWORD PROCESSOR_FAMILY_PPC = 5;
//const DWORD PROCESSOR_FAMILY_SHX = 6;
//const DWORD PROCESSOR_FAMILY_MIPS4 = 7;
const DWORD PROCESSOR_FAMILY_IA64 = 8;
const DWORD PROCESSOR_FAMILY_ARMV8ARCH64 = 9;
const DWORD PROCESSOR_FAMILY_UNK = 0xFFFFFFFF; // unknown
// Note: If the driver support multiple CPU families, this field should be PROCESSOR_FAMILY_UNK until the current processor in the target is clearly identified
// For Context interface, the driver that support multiple CPU should return interface to all potentially supported interfaces but the interface should only positively respond to the one corresponding to the current CPU


typedef
    struct _DEBUG_ACCESS_CAPABILITIES_STRUCT
    {
        BOOL fWriteCBPWhileRunning; // if TRUE, can set or clear code breakpoint while running (on the fly, no need to be halted)
        BOOL fReadCBPWhileRunning;  // if TRUE, can read code breakpoint (list) while running (on the fly, no need to be halted)
        BOOL fWriteDBPWhileRunning; // if TRUE, can set or clear data breakpoint while running (on the fly, no need to be halted)
        BOOL fReadDBPWhileRunning;  // if TRUE, can read data breakpoint (list) while running (on the fly, no need to be halted)
        BOOL fWriteVMWhileRunning;  // if TRUE, can write virtual memory while running (on the fly, no need to be halted)
        BOOL fReadVMWhileRunning;   // if TRUE, can read virtual memory while running (on the fly, no need to be halted)
        BOOL fWritePMWhileRunning;  // if TRUE, can write physical memory or peripherical I/O while running (on the fly, no need to be halted)
        BOOL fReadPMWhileRunning;   // if TRUE, can read physical memory or peripherical I/O while running (on the fly, no need to be halted)
        BOOL fWriteRegWhileRunning; // if TRUE, can write CPU / CP registers while running (on the fly, no need to be halted)
        BOOL fReadRegWhileRunning;  // if TRUE, can read CPU / CP registers while running (on the fly, no need to be halted)
    }
    DEBUG_ACCESS_CAPABILITIES_STRUCT, *PDEBUG_ACCESS_CAPABILITIES_STRUCT;


typedef 
    struct _GLOBAL_TARGET_INFO_STRUCT
    {
        DWORD TargetProcessorFamily;
        DEBUG_ACCESS_CAPABILITIES_STRUCT dbc;
        LPOLESTR szTargetName;
        LPOLESTR szProbeName;
    }
    GLOBAL_TARGET_INFO_STRUCT, *PGLOBAL_TARGET_INFO_STRUCT;


typedef 
    enum _RUN_STATUS_TYPE
    {
        rsRunning,      // The target is currently executing code
        rsHalted,       // The target is completely stopped
        rsError,        // The target is in an error state (warning: different than exception)
        rsUnknown
    }
    RUN_STATUS_TYPE, *PRUN_STATUS_TYPE;


typedef
    enum _PHALT_REASON_TYPE
    {
        hrNone,         // Status type is not rsHalted
        hrUser,         // "Manual" asynchronous halt
        hrException,    // An exception just occured
        hrBp,           // Breakpoint (code or data)
        hrStep,         // We just excuted a single / multiple / range step
        hrUnknown
    }
    HALT_REASON_TYPE, *PHALT_REASON_TYPE;


typedef
    struct _EXCEPTION_TYPE
    {
        DWORD dwCode;         // indicate type / source of exception (platform dependant)
        ADDRESS_TYPE Address; // program / instruction pointer where the exception occured
    } EXCEPTION_TYPE, *PEXCEPTION_TYPE; // Platform dependant


typedef
    enum _CBP_KIND
    {
        cbptAlgo,    // Let the probe driver decide if code breakpoint can be hw or sw based on resources available
        cbptHW,      // Force the code breakpoint to be a hardware one (address comparator in hardware debug logic)
        cbptSW       // Force the code breakpoint to be a software one (bp instruction replacing the regulare instruction)
    } CBP_KIND, *PCBP_KIND;


typedef 
    enum _DATA_ACCESS_TYPE
    {
        daWrite     = 0, 
        daRead      = 1,
        daBoth      = 2, // Don't care
        daExecution = 3, // Execution
        daIOHw	    = 4	 // IO HW memory
    }
    DATA_ACCESS_TYPE, *PDATA_ACCESS_TYPE;


typedef
    struct _BREAKPOINT_SUPPORT_TYPE
    {
        BOOL fCodeBpBypassCountSupported;   // if TRUE, Bypass counter is supported on Code Breakpoint
        BOOL fDataBpBypassCountSupported;   // if TRUE, Bypass counter is supported on Data Breakpoint
        BOOL fDataBpSupported;              // if FALSE, no Data Breakpoint resource are ever available from the target
        BOOL fDataBpMaskableAddress;        // if TRUE, Data Breakpoint address mask can be defined (implies that fDataBpSupported field is TRUE)
        BOOL fDataBpMaskableData;           // if TRUE, Data Breakpoint data mask can be defined (implies that fDataBpSupported field is TRUE)
        BOOL fDataBpDataWidthSpecifiable;   // if TRUE, Data Breakpoint specific data width can be defined (implies that fDataBpSupported field is TRUE)
        BOOL fDataBpReadWriteSpecifiable;   // if TRUE, Data Breakpoint specific data access type can be defined (implies that fDataBpSupported field is TRUE)
        BOOL fDataBpDataMatchSupported;     // if FALSE, data Breakpoint data field is always don't care, triggers only on address compare (data mask should always be 0 - fDataBpMaskableData is Don't care)
    } BREAKPOINT_SUPPORT_TYPE, *PBREAKPOINT_SUPPORT_TYPE;


typedef
    enum _MEM_TYPE
    {
        mtVirtual,
        mtPhysicalOrPeriIO,
        mtContext
    } MEM_TYPE, *PMEM_TYPE;


// Exception information

// These are the actions which the debugger may take in response to an exception raised in the debuggee.

typedef 
    enum _EXCEPTION_DEFAULT_ACTION_TYPE
    {
        edaIgnore,
        edaNotify,
        edaStop
    } EXCEPTION_DEFAULT_ACTION_TYPE;


typedef 
    struct _EXCEPTION_DESCRIPTION_TYPE
    {
        DWORD dwExceptionCode;
        EXCEPTION_DEFAULT_ACTION_TYPE efd;
        wchar_t szDescription [60];
    } EXCEPTION_DESCRIPTION_TYPE;

typedef
    enum _ADDRESS_SPACE_TYPE
    {
        astPhysicalMemory,
        astIoSpace,
    } ADDRESS_SPACE_TYPE;

#pragma endregion

#pragma region IOCTL codes and new structures replacing IOCTLs in EXDIv1
typedef enum
{
    // Marker for the beginning of the enum.  Start at
    // a value other than zero to prevent obvious collisions
    // with other Ioctl codes.
    DBGENG_EXDI3_IOC_BEFORE_FIRST = 0x38664,

    // Marker for the end of the enum.
    DBGENG_EXDI3_IOC_AFTER_LAST
} DBGENG_EXDI3_IOCTL_CODE;


const DWORD DBGENG_EXDI3_IOCTL_BREAKPOINT_NONE = 0;
const DWORD DBGENG_EXDI3_IOCTL_BREAKPOINT_CODE = 1;
const DWORD DBGENG_EXDI3_IOCTL_BREAKPOINT_DATA = 2;

typedef struct _DBGENG_EXDI3_GET_BREAKPOINT_HIT_OUT
{
    ADDRESS_TYPE Address;
    ULONG AccessWidth;
    DATA_ACCESS_TYPE AccessType;
    ULONG Type;
} DBGENG_EXDI3_GET_BREAKPOINT_HIT_OUT, *PDBGENG_EXDI3_GET_BREAKPOINT_HIT_OUT;


#pragma endregion

[
    object,
    uuid(22EFA264-6FD7-4992-9427-125B511A477C),
    oleautomation,
]
interface IeXdiServerFactory3 : IUnknown
{
    HRESULT CreateExdiServer([in] LPCWSTR pConstructorArguments, [out] IUnknown **pServer);
}

#pragma region IeXdiServer3 interface

[
    object,
    uuid(2E501506-9703-4B6F-9D0D-6B42B0E41E6F),
    oleautomation,
    helpstring("IeXdiServer3 interface - Main interface for hardware debugging plugins. Copyright (C) 1999-2013 Microsoft Corporation"),
    pointer_default(ref),
]
interface IeXdiServer3 : IUnknown
{

/*++

Routine Name:

    GetTargetInfo

Routine Description:

    Return Global information on Target (and Probe / emulator)

Argument(s):

    pgti            - Returns Global Target Info structure
    
Return Value:

    Error status:
        S_OK:                           Function successful
        EXDI3_E_NOTIMPL:                 Not implemented
        EXDI3_E_OUTOFMEMORY:             Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:              One or more arguments are invalid
        EXDI3_E_ABORT:                   Operation aborted
        EXDI3_E_FAIL:                    Unspecified failure
        EXDI3_E_COMMUNICATION:           Communication error between host driver and target

--*/

HRESULT GetTargetInfo
(
    [out] PGLOBAL_TARGET_INFO_STRUCT pgti
);


/*++

Routine Name:

    GetRunStatus

Routine Description:

    Return the current Run Status (Running, Stopped due to Breakpoint ...).

Argument(s):

    persCurrent     - Returns the current Run Status Type
    pehrCurrent     - Returns the current Halt Reason Type (hrNone if Run Status is not Halted)
    pCurrentExecAddress - Returns the current program / instruction pointer if Run Status is Halted, undefined otherwise.
    pdwExceptionCode - Returns the type / source of exception (Code is platform dependant) if Halted due to exception ((rsHalted == *persCurrent) && (hrException == *pehrCurrent)), undefined otherwise.
 
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT GetRunStatus 
(
    [out] PRUN_STATUS_TYPE persCurrent, 
    [out] PHALT_REASON_TYPE pehrCurrent,
    [out] ADDRESS_TYPE *pCurrentExecAddress, 
    [out] DWORD *pdwExceptionCode,
    [out] DWORD *pdwProcessorNumberOfLastEvent
);


/*++

Routine Name:

    GetLastException

Routine Description:

    Return the last exception that happened.

Argument(s):

    pexLast          - Returns the last exception that occured (if none return value is EXDI3_E_NOLASTEXCEPTION)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_NOLASTEXCEPTION:          No exception occured already, cannot return last
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT Run 
(
    void
);


/*++

Routine Name:

    Halt

Routine Description:

    Command target to Halt (complete control unit freeze).

Argument(s):

    none
    
Return Value:

    Error status:
        S_OK:                        Function successful (and target was not already halted)
        EXDI3_I_TGTALREADYHALTED:     Indicates that the target was already halted
        EXDI3_E_NOTIMPL:              Not implemented
        EXDI3_E_OUTOFMEMORY:          Failed to allocate necessary memory
        EXDI3_E_ABORT:                Operation aborted
        EXDI3_E_FAIL:                 Unspecified failure
        EXDI3_E_COMMUNICATION:        Communication error between host driver and target

--*/

HRESULT Halt 
(
    void
);


/*++

Routine Name:

    DoSingleStep

Routine Description:

    Command target to execute a single instruction and then halt again.

Argument(s):

    none
    
Return Value:

    Error status:
        S_OK:                        Function successful
        EXDI3_E_TGTWASNOTHALTED:      The target was not halted
        EXDI3_E_NORESAVAILABLE:       No Resource available to do Single Step (not direct on-chip support or no bp resource avail)
                                         If Single Step support not available, return this error code too
        EXDI3_E_NOTIMPL:              Not implemented
        EXDI3_E_OUTOFMEMORY:          Failed to allocate necessary memory
        EXDI3_E_ABORT:                Operation aborted
        EXDI3_E_FAIL:                 Unspecified failure
        EXDI3_E_COMMUNICATION:        Communication error between host driver and target

--*/

HRESULT DoSingleStep 
(
    DWORD dwProcessorNumber
);

/*++

Routine Name:

    Reboot

Routine Description:

    Command target to reboot (external Reset).

Argument(s):

    none
    
Return Value:

    Error status:
        S_OK:                        Function successful
        EXDI3_E_NOREBOOTAVAIL:        The external reset is not available programatically to the probe
        EXDI3_E_NOTIMPL:              Not implemented
        EXDI3_E_OUTOFMEMORY:          Failed to allocate necessary memory
        EXDI3_E_ABORT:                Operation aborted
        EXDI3_E_FAIL:                 Unspecified failure
        EXDI3_E_COMMUNICATION:        Communication error between host driver and target

--*/

HRESULT Reboot 
(
    void
);

/*++

Routine Name:

    GetNbCodeBpAvail

Routine Description:

    Get Code Breakpoint availability

Argument(s):

    pdwNbHwCodeBpAvail - Returns the number of Hardware Code Breakpoint still available on the target.
                            If no limit known, returns -1 (4294967295)
                            Note: If Code Breakpoint support not available, returns 0 and Error Status S_OK
    pdwNbSwCodeBpAvail - Returns the number of Software Code Breakpoint still available on the target.
                            If no limit known, returns -1 (4294967295)
                            Note: If code Breakpoint support not available, returns 0 and Error Status S_OK
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadCBPWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT GetNbCodeBpAvail 
(
    [out] DWORD *pdwNbHwCodeBpAvail, 
    [out] DWORD *pdwNbSwCodeBpAvail
);


/*++

Routine Name:

    GetNbDataBpAvail

Routine Description:

    Get Data Breakpoint availability

Argument(s):

    pdwNbDataBpAvail - Returns the number of Data Breakpoint still available on the target.
                            If no limit known, returns -1 (4294967295)
                            Note: If Data Breakpoint support not available, returns 0 and Error Status S_OK
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadDBPWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT GetNbDataBpAvail 
(
    [out] DWORD *pdwNbDataBpAvail
);


/*++

Routine Name:

    AddCodeBreakpoint

Routine Description:

    Add new code Breakpoint. The newly created breakpoint is initially disabled (can be enabled with *ppieXdiCodeBreakpoint->SetState(...)) 
    and so should not use any resources.
    Note: Although several client can keep track of the same breakpoint(s), this is not recommended for the fact that there is no bp change notification.

Argument(s):

    Address         - Address of the instruction to break on
    cbpk            - Indicates if the code breakpoint must be hardware, software (bp instruction) or 
                        if the probe driver can decide based on its algorithm and resources available.
                        Note: In the case of sw bp, the probe driver must keep track of instruction being replaced.
    mt                - Instruction Memory type. Indicates whether this memory address concerns virtual memory or physical 
                        memory (pheripherical IO is not applicable and mtContext value is not accepted)
    dwExecMode        - In the case of multiple mode processors, give a hint (if necessary) on the process mode at the
                        time of the execution of the code where to set the breakpoint. For example, in the case of a
                        software breakpoint, the trap instruction may be different in 16 bit mode than 32 bit mode on
                        processors having the 2 modes (ARM and MIPS).
                        Should be 0 for 32 bit mode (default). Should be 1 for 16 bit mode.
    dwTotalBypassCount - Total number of bypass before triggering a CPU halt on this breakpoint
                        Note: Should be 0 if Total Bypass Count is not supported - see BREAKPOINT_SUPPORT_TYPE.fCodeBpBypassCountSupported
    ppieXdiCodeBreakpoint - Returns a pointer to the newly created breakpoint object's interface.
    
Return Value:

    Error status:
        S_OK:                        Function successful
        EXDI3_E_NORESAVAILABLE:       No (Breakpoint) Resource available, cannot instantiate Breakpoint (in the kind requested)
                                        If Code Breakpoint support not available, also return this error code
        EXDI3_E_CANNOTWHILETGTRUNNING Cannot proceed while target running. Must halt the target first.
                                        Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                        see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteCBPWhileRunning
        EXDI3_E_NOTIMPL:              Not implemented
        EXDI3_E_OUTOFMEMORY:          Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:           One or more arguments are invalid
        EXDI3_E_ABORT:                Operation aborted
        EXDI3_E_FAIL:                 Unspecified failure
        EXDI3_E_COMMUNICATION:        Communication error between host driver and target

--*/

HRESULT AddCodeBreakpoint 
(
    [in] ADDRESS_TYPE Address,
    [in] CBP_KIND cbpk,
    [in] MEM_TYPE mt,
    [in] DWORD dwExecMode,
    [in] DWORD dwTotalBypassCount,
    [out] IeXdiCodeBreakpoint3 **ppieXdiCodeBreakpoint
);


/*++

Routine Name:

    DelCodeBreakpoint

Routine Description:

    Delete existing code Breakpoint from driver internal list. The breakpoint will be automatically disabled (so any triggering resources will be remove).
    The breakpoint instance will be removed only when all references to it are released.

Argument(s):

    pieXdiCodeBreakpoint - Pointer to breakpoint object's interface.
    
Return Value:

    Error status:
        S_OK:                        Function successful
        EXDI3_E_NORESAVAILABLE:       No (Breakpoint) Resource available, cannot instantiate Breakpoint (in the kind requested)
                                        If Code Breakpoint support not available, also return this error code
        EXDI3_E_CANNOTWHILETGTRUNNING Cannot proceed while target running. Must halt the target first.
                                        Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                        see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteCBPWhileRunning
        EXDI3_E_NOTIMPL:              Not implemented
        EXDI3_E_OUTOFMEMORY:          Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:           One or more arguments are invalid
        EXDI3_E_ABORT:                Operation aborted
        EXDI3_E_FAIL:                 Unspecified failure
        EXDI3_E_COMMUNICATION:        Communication error between host driver and target

--*/

HRESULT DelCodeBreakpoint 
(
    [in] IeXdiCodeBreakpoint3 *pieXdiCodeBreakpoint
);


/*++

Routine Name:

    AddDataBreakpoint

Routine Description:

    Add new data Breakpoint. The newly created breakpoint is initially disabled (can be enabled with *ppieXdiDataBreakpoint->SetState(...)) 
    and so should not use any resources.
    Note: Although several client can keep track of the same breakpoint(s), this is not recommended for the fact that there is no bp change notification.
    Note: This function does not support definition of multiple access data breakpoints (array of element, an element being a memory object contained in a single access).

Argument(s):

    Address         - Address of the data to be accessed to break on (only bits set in AddressMask are significant).
    AddressMask     - Mask to apply on Address comparison on for matching bits (if bit set, do compare, otherwise ignore).
                        Note: Should be -1 if Address Mask not supported by target, otherwise the probe driver should return EXDI3_E_INVALIDARG error.
    dwData          - Value of the Data to be accessed to break on (only bits set in DataMask are significant).   
    dwDataMask      - Mask to apply on Data comparison on for matching bits (if bit set, do compare, otherwise ignore).
                        Note: Should be -1 (4294967295) if Data Mask not supported by target, otherwise the probe driver should return EXDI3_E_INVALIDARG error.
    bAccessWidth    - Data Width in bits (byte=8, word=16, dword=32, and other if supported by target - the maximum being 32 bits)
                        Note: Should be -1 (255) for "DON'T CARE" meaning (to be ignored - any size triggers the BP) or
                              if Data Width specification not supported by target, otherwise the probe driver should return EXDI3_E_INVALIDARG error.
    mt                - Data memory type.  Indicates whether this memory address concerns virtual memory, physical memory or pheripherical IO (mtContext value is not accepted)
    bAddressSpace   - Address space of the data breakpoint if mt is mtPhysicalOrPeriIO (convention: 0 = Physical Memory, 1 = Peripherical I/O if not memory mapped, 2..255 = free for custom use)
    da              - Data Access type: Read access, Write access or both (don't care)
                        Note: Should be 2 (daBoth) if Data Access type specification not supported by target, otherwise the probe driver should return EXDI3_E_INVALIDARG error.
    dwTotalBypassCount - Total number of bypass before triggering a CPU halt on this breakpoint
                        Note: Should be 0 if Total Bypass Count is not supported - see BREAKPOINT_SUPPORT_TYPE.fDataBpBypassCountSupported
    ppieXdiDataBreakpoint - Returns a pointer to the newly created breakpoint object's interface.
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_NORESAVAILABLE:           No (Breakpoint) Resource available, cannot instantiate Breakpoint
                                            If Data Breakpoint support not available, also return this error code.
        EXDI3_E_CANNOTWHILETGTRUNNING:    Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteDBPWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT AddDataBreakpoint 
(
    [in] ADDRESS_TYPE Address, 
    [in] ADDRESS_TYPE AddressMask, 
    [in] DWORD dwData, 
    [in] DWORD dwDataMask, 
    [in] BYTE bAccessWidth,
    [in] MEM_TYPE mt,
    [in] BYTE bAddressSpace,
    [in] DATA_ACCESS_TYPE da,
    [in] DWORD dwTotalBypassCount,
    [out] IeXdiDataBreakpoint3 **ppieXdiDataBreakpoint
);


/*++

Routine Name:

    DelDataBreakpoint

Routine Description:

    Delete existing data Breakpoint from driver internal list. The breakpoint will be automatically disabled (so any triggering resources will be remove).
    The breakpoint instance will be removed only when all references to it are released.

Argument(s):

    pieXdiDataBreakpoint - Pointer to breakpoint object's interface.
    
Return Value:

    Error status:
        S_OK:                        Function successful
        EXDI3_E_NORESAVAILABLE:       No (Breakpoint) Resource available, cannot instantiate Breakpoint (in the kind requested)
                                        If Data Breakpoint support not available, also return this error code
        EXDI3_E_CANNOTWHILETGTRUNNING Cannot proceed while target running. Must halt the target first.
                                        Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                        see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteCBPWhileRunning
        EXDI3_E_NOTIMPL:              Not implemented
        EXDI3_E_OUTOFMEMORY:          Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:           One or more arguments are invalid
        EXDI3_E_ABORT:                Operation aborted
        EXDI3_E_FAIL:                 Unspecified failure
        EXDI3_E_COMMUNICATION:        Communication error between host driver and target

--*/

HRESULT DelDataBreakpoint 
(
    [in] IeXdiDataBreakpoint3 *pieXdiDataBreakpoint
);

/*++

Routine Name:

    StartNotifyingRunChg

Routine Description:

    Add new object in list of one to notify of a Run State change.
    The driver will immediately do a AddRef() on the object before returning.
    
Argument(s):

    pieXdiClientNotifyRunChg - advise sink: pointer to the IeXdiClientNotifyRunChg callback interface of the object to be notified by the driver
    pdwConnectionCookie - Returns cookie to the callback connection just made. This can be used later by the driver to delete the connection 
                            (using StopNotifyingRunChg). If the connection is not successfully established, this cookie value is not meaningfull.
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_ADVISELIMIT               The connection point has already reached its limit of connections and cannot accept any more. 
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT StartNotifyingRunChg 
(
    [in] IeXdiClientNotifyRunChg3 *pieXdiClientNotifyRunChg,
    [out] DWORD *pdwConnectionCookie
);


/*++

Routine Name:

    StopNotifyingRunChg

Routine Description:

    Remove object in list of one to notify of a Run State change.
    The driver will immediately do a Release() on the object before returning.
    
Argument(s):

    dwConnectionCookie - Cookie to the callback connection to cancel.
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT StopNotifyingRunChg 
(
    [in] DWORD dwConnectionCookie
);


/////////////////////////////////////////////////////////////////////////////
// Memory, I/O and Register Access section of the Interface
/////////////////////////////////////////////////////////////////////////////


/*++

Routine Name:

    ReadVirtualMemory

Routine Description:

    Read Virtual Memory block. This is the default memory read.
    Note: The memory content returned to this function should be "sanitized" (compensated for the artefacts of
        software breakpoints - or of any other modifications of the memory produced by the debugging activity of 
        the driver, probe or target). In general, the driver internal mechanism should be transparent to the client.

Argument(s):

    Address         - Starting address of the data buffer to be accessed on the target.
    dwNbElemToRead  - Number of element(s) (of bAccessWidth bits) to be accessed.
    bAccessWidth    - Data Width in bits (byte=8, word=16, dword=32, ddword=64, and other if supported by target).
    pbReadBuffer    - Buffer (of bytes) on which result of reading is written. Must be large enough to hold all elements returned (pdwNbElementEffectRead)
                        Note: Elements must be aligned on byte boundary. Bit padding must be added if bAccessWidth is not multiple of 8.
                        WARNING: the server should handle buffers of at least 64KB.
    pdwNbElementEffectRead - Returns the number of element effectively read. This is used by the client to speed up in case of access 
                        violation (EXDI3_E_ACCESSVIOLATION) in the range: If an entire range is not accessible, this returned value should be 0, 
                        so there is no need to query the range with smaller granularity.
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_ACCESSVIOLATION:          Access violation on at least one element in address range specificified by the operation
        EXDI3_E_CANNOTWHILETGTRUNNING:    Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadVMWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT ReadVirtualMemory 
(
    [in] ADDRESS_TYPE Address, 
    [in] DWORD dwBytesToRead, 
    [out] SAFEARRAY(BYTE) *pReadBuffer
);


/*++

Routine Name:

    WriteVirtualMemory

Routine Description:

    Write Virtual Memory block. This is the default memory write.
    Note: The memory content provided to this function should be "sanitized" (compensated for the artefacts of
        software breakpoints - or of any other modifications of the memory produced by the debugging activity of 
        the driver, probe or target). In general, the driver internal mechanism should be transparent to the client.

Argument(s):

    Address         - Starting address of the data buffer to be accessed on the target.
    dwNbElemToWrite - Number of element(s) (of bAccessWidth bits) to be accessed.
    bAccessWidth    - Data Width in bits (byte=8, word=16, dword=32, ddword=64, and other if supported by target).
    pbWriteBuffer   - Buffer (of bytes) on which result of writing is written. Must be large enough to hold all elements (dwNbElemToWrite)
                        Note: Elements must be aligned on byte boundary. Bit padding must be added if bAccessWidth is not multiple of 8.
                        WARNING: the server should handle buffers of at least 64KB.
    pdwNbElementEffectWritten - Returns the number of element effectively written. This is used by the client to speed up in case of access 
                        violation (EXDI3_E_ACCESSVIOLATION) in the range: If an entire range is not accessible, this returned value should be 0, 
                        so there is no need to query the range with smaller granularity.
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_ACCESSVIOLATION:          Access violation on at least one element in address range specificified by the operation
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteVMWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT WriteVirtualMemory 
(
    [in] ADDRESS_TYPE Address, 
    [in] SAFEARRAY(BYTE) pBuffer,
    [out] DWORD *pdwBytesWritten
);


/*++

Routine Name:

    ReadPhysicalMemoryOrPeriphIO

Routine Description:

    Read block of data to Physical Memory or peripherical I/O.
    Note: The memory content returned to this function should be "sanitized" (compensated for the artefacts of
        software breakpoints - or of any other modifications of the memory produced by the debugging activity of 
        the driver, probe or target). In general, the driver internal mechanism should be transparent to the client.

Argument(s):

    Address         - Starting address of the data buffer to be accessed on the target.
    bAddressSpace   - Address space to be accessed (convention: 0 = Physical Memory, 1 = Peripherical I/O if not memory mapped, 2..255 = free for custom use)
    dwNbElemToRead  - Number of element(s) (of bAccessWidth bits) to be accessed.
    bAccessWidth    - Data Width in bits (byte=8, word=16, dword=32, ddword=64, and other if supported by target).
    pbReadBuffer    - Buffer (of bytes) on which result of reading is written. Must be large enough to hold all elements (dwNbElemToRead)
                        Note: Elements must be aligned on byte boundary. Bit padding must be added if bAccessWidth is not multiple of 8.
                        WARNING: the server should handle buffers of at least 64KB.
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadPMWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT ReadPhysicalMemoryOrPeriphIO 
(
    [in] ADDRESS_TYPE Address, 
    [in] ADDRESS_SPACE_TYPE AddressSpace, 
    [in] DWORD dwBytesToRead, 
    [out] SAFEARRAY(BYTE) *pReadBuffer
);


/*++

Routine Name:

    WritePhysicalMemoryOrPeriphIO

Routine Description:

    Write block of data to Physical Memory or peripherical I/O.
    Note: The memory content provided to this function should be "sanitized" (compensated for the artefacts of
        software breakpoints - or of any other modifications of the memory produced by the debugging activity of 
        the driver, probe or target). In general, the driver internal mechanism should be transparent to the client.

Argument(s):

    Address         - Starting address of the data buffer to be accessed on the target.
    bAddressSpace   - Address space to be accessed (convention: 0 = Physical Memory, 1 = Peripherical I/O if not memory mapped, 2..255 = free for custom use)
    dwNbElemToWrite - Number of element(s) (of bAccessWidth bits) to be accessed.
    bAccessWidth    - Data Width in bits (byte=8, word=16, dword=32, ddword=64, and other if supported by target).
    pbWriteBuffer   - Buffer (of bytes) on which result of writing is written. Must be large enough to hold all elements (dwNbElemToWrite)
                        Note: Elements must be aligned on byte boundary. Bit padding must be added if bAccessWidth is not multiple of 8.
                        WARNING: the server should handle buffers of at least 64KB.
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWritePMWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT WritePhysicalMemoryOrPeriphIO 
(
    [in] ADDRESS_TYPE Address, 
    [in] ADDRESS_SPACE_TYPE AddressSpace, 
    [in] SAFEARRAY(BYTE) pBuffer,
    [out] DWORD *pdwBytesWritten
);


/////////////////////////////////////////////////////////////////////////////
// IoCtl (back door - non formated api) section of the Interface
/////////////////////////////////////////////////////////////////////////////


/*++

Routine Name:

    Ioctl

Routine Description:

    Back door / non formated interface.

Argument(s):

    dwBuffInSize    - Size in byte of *pbyBufferIn
    pbBufferIn      - Raw byte buffer to hold input parameter(s)
    dwBuffOutSize   - Size in byte of *pbyBufferOut
    pdwEffectBuffOutSize - Returns effective size in byte of *pbyBufferOut (must be smaller than dwBuffOutSize)
    pbBufferOut     - Raw byte buffer to hold output parameter(s)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed requested operation while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT (flag depends on operation requested)
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT Ioctl 
(
    [in] SAFEARRAY(BYTE) pInputBuffer,
    [in] DWORD dwBuffOutSize, 
    [out] SAFEARRAY(BYTE) *pOutputBuffer
);


HRESULT GetNumberOfProcessors([out] DWORD *pdwNumberOfProcessors);

HRESULT GetLastHitBreakpoint([out] DBGENG_EXDI3_GET_BREAKPOINT_HIT_OUT *pBreakpointInformation);

HRESULT GetKPCRForProcessor([in] DWORD dwProcessorNumber, [out] ULONG64 *pKPCRPointer);

HRESULT ReadKdVersionBlock([in] DWORD dwBufferSize, [out] SAFEARRAY(BYTE) *pKdVersionBlockBuffer);

HRESULT SetKeepaliveInterface([in] IeXdiKeepaliveInterface3 *pKeepalive);

HRESULT ReadMSR([in] DWORD dwProcessorNumber, [in] DWORD dwRegisterIndex, [out] ULONG64 *pValue);

HRESULT WriteMSR([in] DWORD dwProcessorNumber, [in] DWORD dwRegisterIndex, [in] ULONG64 value);

}; // interface IeXdiServer

#pragma endregion

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiCodeBreakpoint
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Code Breakpoint Interface
/////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid(386D8BCB-9D1E-4BF4-BE90-90D7802545FE),
    oleautomation,
    helpstring("IeXdiCodeBreakpoint3 interface - eXdi Server Code Breakpoint 1.0 for Platform Builder 3.0 debugger - Copyright (C) 1999-2007 Microsoft Corporation"),
    pointer_default(ref),
]
interface IeXdiCodeBreakpoint3 : IUnknown
{

/*++

Routine Name:

    GetAttributes

Routine Description:

    Get Code Breakpoint current characteristics.

Argument(s):

    pAddress        - Returns address of the instruction to be accessed to break on.
    pcbpk           - Returns the kind of code breakpoint (hardware, software (bp instruction) or if the probe driver 
                        can decide based on its algorithm and resources available).
                        Note: In the case of sw bp, the probe driver must keep track of instruction being replaced.
    pmt                - Returns Instruction memory type. Indicates whether this memory address concerns virtual memory or physical 
                        memory (pheripherical IO not applicable and mtContext value is not accepted)
    pdwExecMode        - Returns processor execution mode. In the case of multiple mode processors, this gives a hint 
                        (if necessary) on the process mode at the time of the execution of the code where the breakpoint is set.
                        For example, in the case of a software breakpoint, the trap instruction may be different in 16 bit mode 
                        than 32 bit mode on    processors having the 2 modes (ARM and MIPS).
                        Should be 0 for 32 bit mode (default). Should be 1 for 16 bit mode.
    pdwTotalBypassCount - Returns the number of times the trigger of a CPU halt should be bypassed if the breakpoint condition is met.
    pdwBypassedOccurences - Returns the number of occurences of bypass related to this breakpoint already seen. Note: initial value (always if not supported) is 0
                            Note: this value is reset to 0 everytime the CPU is halted due to this breakpoint.
    pfEnabled       - Returns TRUE if Breakpoint is enabled. Note: default value at creation is FALSE

Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING:    Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadCBPWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT GetAttributes
(
    [out] PADDRESS_TYPE pAddress, 
    [out] PCBP_KIND pcbpk,
    [out] PMEM_TYPE pmt,
    [out] DWORD *pdwExecMode,
    [out] DWORD *pdwTotalBypassCount,
    [out] DWORD *pdwBypassedOccurences,
    [out] BOOL *pfEnabled
);


/*++

Routine Name:

    SetState

Routine Description:

    Enable or Disable Breakpoint.
        Note: this function should free (in case of disable) or (re)allocate (in case of enable) breakpoint triggering resource if applicable

Argument(s):

    fEnabled        - TRUE if Breakpoint is enabled.
    fResetBypassedOccurences - Reset the number of occurences of bypass related to this breakpoint already seen.
                        Note: this action is equivalent to the reset implicitely done everytime the CPU is halted due to this breakpoint.
                        Note: if this bypass counting feature is not supported, the value of this parameter is don't care 

Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING:    Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadCBPWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT SetState
(
    [in] BOOL fEnabled,
    [in] BOOL fResetBypassedOccurences
);


}; // IeXdiCodeBreakpoint


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiDataBreakpoint3
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Data Breakpoint Interface
/////////////////////////////////////////////////////////////////////////////


[
    object,
    uuid(FC90E444-6E23-40C1-A8D0-1203C8ADB324),
    oleautomation,
    helpstring("IeXdiDataBreakpoint3 interface - eXdi Server Data Breakpoint 1.0 for Platform Builder 3.0 debugger - Copyright (C) 1999-2007 Microsoft Corporation"),
    pointer_default(ref),
]
interface IeXdiDataBreakpoint3 : IUnknown
{

/*++

Routine Name:

    GetAttributes

Routine Description:

    Get Data Breakpoint current characteristics.

Argument(s):

    pAddress        - Returns address of the data to be accessed to break on (only bits set in AddressMask are significant).
    pAddressMask    - Returns mask to apply on Address comparison on for matching bits (if bit set, do compare, otherwise ignore).
                       Note: Returns -1 if Address Mask not supported by target.
    pdwData         - Returns value of the Data to be accessed to break on (only bits set in DataMask are significant).   
    pdwDataMask     - Returns mask to apply on Data comparison on for matching bits (if bit set, do compare, otherwise ignore).
                       Note: Returns -1 (4294967295) if Data Mask not supported by target.
    pbAccessWidth   - Returns Data Width in bits (byte=8, word=16, dword=32, and other if supported by target - the maximum being 32 bits)
                       Note: Returns -1 (255) if Data Width specification not supported by target.
    pmt                - Returns Data memory type.  Indicates whether this memory address concerns virtual memory, physical memory or pheripherical IO 
                        (mtContext value is not accepted)
    pbAddressSpace  - Returns Address space of the data breakpoint if *pmt is mtPhysicalOrPeriIO (convention: 0 = Physical Memory, 1 = Peripherical I/O
                        if not memory mapped, 2..255 = free for custom use)
    pda             - Returns Data Access type: Read access, Write access or both (don't care)
                       Note: Returns 2 (daBoth) if Data Access type specification not supported by target.
    pdwTotalBypassCount - Returns the number of times the trigger of a CPU halt should be bypassed if the breakpoint condition is met.
    pdwBypassedOccurences - Returns the number of occurences of bypass related to this breakpoint already seen. Note: initial value (always if not supported) is 0
                            Note: this value is reset to 0 everytime the CPU is halted due to this breakpoint.
    pfEnabled       - Returns TRUE if Breakpoint is enabled. Note: default value at creation is FALSE

Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING:    Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadDBPWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT GetAttributes
(
    [out] PADDRESS_TYPE pAddress, 
    [out] PADDRESS_TYPE pAddressMask, 
    [out] DWORD *pdwData, 
    [out] DWORD *pdwDataMask, 
    [out] BYTE *pbAccessWidth, 
    [out] PMEM_TYPE pmt,
    [out] BYTE *pbAddressSpace,
    [out] PDATA_ACCESS_TYPE pda,
    [out] DWORD *pdwTotalBypassCount,
    [out] DWORD *pdwBypassedOccurences,
    [out] BOOL *pfEnabled
);


/*++

Routine Name:

    SetState

Routine Description:

    Enable or Disable Breakpoint.
        Note: this function should free (in case of disable) or (re)allocate (in case of enable) breakpoint triggering resource if applicable

Argument(s):

    fEnabled        - TRUE if Breakpoint is enabled.
    fResetBypassedOccurences - Reset the number of occurences of bypass related to this breakpoint already seen.
                        Note: this action is equivalent to the reset implicitely done everytime the CPU is halted due to this breakpoint.
                        Note: if this bypass counting feature is not supported, the value of this parameter is don't care 

Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING:    Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadCBPWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT SetState
(
    [in] BOOL fEnabled,
    [in] BOOL fResetBypassedOccurences
);


}; // IeXdiDataBreakpoint


const DWORD SIZE_OF_80387_REGISTERS_IN_BYTES = 80;


typedef
    struct _CONTEXT_X86
    {
        struct 
        {
            BOOL fSegmentRegs;
            BOOL fControlRegs;
            BOOL fIntegerRegs;
            BOOL fFloatingPointRegs;
            BOOL fDebugRegs;
        }       RegGroupSelection;  // These flags are used to select groups of registers only 
                                    // (instead of the totality) for reading or writing.
        // both Segment & Control registers (used if either RegGroupSelection.fSegmentRegs or
        //  RegGroupSelection.fControlRegs is TRUE).
        DWORD   SegCs;
        DWORD   SegSs;        
        // Segment registers (used if RegGroupSelection.fSegmentRegs is TRUE).
        //  except CS and SS which are in "Segment and Control" - see above
        DWORD   SegGs;
        DWORD   SegFs;
        DWORD   SegEs;
        DWORD   SegDs;
        // Control registers (used if RegGroupSelection.fControlRegs is TRUE).
        //  except CS and SS which are in "Segment and Control" - see above
        DWORD   EFlags;
        DWORD   Ebp;
        DWORD   Eip;
        DWORD   Esp;
        // Integer registers (used if RegGroupSelection.fIntegerRegs is TRUE).
        DWORD   Eax;
        DWORD   Ebx;
        DWORD   Ecx;
        DWORD   Edx;
        DWORD   Esi;
        DWORD   Edi;
        // Floating point registers (used if RegGroupSelection.fFloatingPointRegs is TRUE).
        DWORD   ControlWord;
        DWORD   StatusWord;
        DWORD   TagWord;
        DWORD   ErrorOffset;
        DWORD   ErrorSelector;
        DWORD   DataOffset;
        DWORD   DataSelector;
        BYTE    RegisterArea [SIZE_OF_80387_REGISTERS_IN_BYTES];
        DWORD   Cr0NpxState;
        // Debug registers (used if RegGroupSelection.fDebugRegs is TRUE)
        DWORD   Dr0;
        DWORD   Dr1;
        DWORD   Dr2;
        DWORD   Dr3;
        DWORD   Dr6;
        DWORD   Dr7;
    } CONTEXT_X86, *PCONTEXT_X86;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiX86Context
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


// X86 context access interface

[
    object,
    uuid(EBBBE2D6-9B1E-4F35-B956-28A78C348F0F),
    oleautomation,
    helpstring("IeXdiX86Context3 interface - eXdi Context access for X86 processors 1.0 for Platform Builder 3.0 debugger - Copyright (C) 1999-2007 Microsoft Corporation"),
    pointer_default(ref),
]
interface IeXdiX86Context3 : IUnknown
{


/*++

Routine Name:

    GetContext

Routine Description:

    Read Context - Read a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be read only 

Argument(s):

    pContext        - Return context (CPU dependant structure). 
                        Note: The context is also passed in to indicate only the RegGroupSelection (which reg groups are read)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT GetContext 
(
    [in] DWORD dwProcessorNumber,
    [in, out] PCONTEXT_X86 pContext
);


/*++

Routine Name:

    SetContext

Routine Description:

    Write Context - Write a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be written only 

Argument(s):

    Context        - Passes context (CPU dependant structure). 
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT SetContext 
(
    [in] DWORD dwProcessorNumber,
    [in] CONTEXT_X86 Context
);


}; // interface IeXdiX86Context



typedef 
    struct _X86_SEG_DESC_INFO
    {
        DWORD Base;
        DWORD Limit;
        DWORD Flags;
    } X86_SEG_DESC_INFO;

typedef 
    struct _X86_SSE_REG
    {
        DWORD Reg0;
        DWORD Reg1;
        DWORD Reg2;
        DWORD Reg3;
    } X86_SSE_REG;

#define X86_NUM_SSE_REGS 8

typedef
    struct _CONTEXT_X86_EX
    {
        struct 
        {
            BOOL fSegmentRegs;
            BOOL fControlRegs;
            BOOL fIntegerRegs;
            BOOL fFloatingPointRegs;
            BOOL fDebugRegs;
            BOOL fSegmentDescriptors;
            BOOL fSSERegisters;
            BOOL fSystemRegisters;
        }       RegGroupSelection;  // These flags are used to select groups of registers only 
                                    // (instead of the totality) for reading or writing.
        // both Segment & Control registers (used if either RegGroupSelection.fSegmentRegs or
        //  RegGroupSelection.fControlRegs is TRUE).
        DWORD   SegCs;
        DWORD   SegSs;        
        // Segment registers (used if RegGroupSelection.fSegmentRegs is TRUE).
        //  except CS and SS which are in "Segment and Control" - see above
        DWORD   SegGs;
        DWORD   SegFs;
        DWORD   SegEs;
        DWORD   SegDs;
        // Control registers (used if RegGroupSelection.fControlRegs is TRUE).
        //  except CS and SS which are in "Segment and Control" - see above
        DWORD   EFlags;
        DWORD   Ebp;
        DWORD   Eip;
        DWORD   Esp;
        // Integer registers (used if RegGroupSelection.fIntegerRegs is TRUE).
        DWORD   Eax;
        DWORD   Ebx;
        DWORD   Ecx;
        DWORD   Edx;
        DWORD   Esi;
        DWORD   Edi;
        // Floating point registers (used if RegGroupSelection.fFloatingPointRegs is TRUE).
        DWORD   ControlWord;
        DWORD   StatusWord;
        DWORD   TagWord;
        DWORD   ErrorOffset;
        DWORD   ErrorSelector;
        DWORD   DataOffset;
        DWORD   DataSelector;
        BYTE    RegisterArea [SIZE_OF_80387_REGISTERS_IN_BYTES];
        DWORD   Cr0NpxState;
        // Debug registers (used if RegGroupSelection.fDebugRegs is TRUE)
        DWORD   Dr0;
        DWORD   Dr1;
        DWORD   Dr2;
        DWORD   Dr3;
        DWORD   Dr6;
        DWORD   Dr7;
        // Descriptors and base registers (used if RegGroupSelection.fSegmentDescriptors is TRUE)
        X86_SEG_DESC_INFO DescriptorCs;
        X86_SEG_DESC_INFO DescriptorSs;
        X86_SEG_DESC_INFO DescriptorGs;
        X86_SEG_DESC_INFO DescriptorFs;
        X86_SEG_DESC_INFO DescriptorEs;
        X86_SEG_DESC_INFO DescriptorDs;
        DWORD IdtBase;
        DWORD IdtLimit;
        DWORD GdtBase;
        DWORD GdtLimit;
        DWORD Ldtr;
        X86_SEG_DESC_INFO DescriptorLdtr;
        DWORD Tr;
        X86_SEG_DESC_INFO DescriptorTr;
        // System registers (used if RegGroupSelection.fSystemRegisters is TRUE)
        DWORD Cr0;
        DWORD Cr2;
        DWORD Cr3;
        DWORD Cr4;
        // SSE registers (used if RegGroupSelection.fSSERegisters is TRUE)
        DWORD Mxcsr;
        X86_SSE_REG Sse[X86_NUM_SSE_REGS];
    } CONTEXT_X86_EX, *PCONTEXT_X86_EX;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiX86ExContext
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


// X86 context access interface

[
    object,
    uuid(3F2A6A8A-D56B-4605-8A93-AC1C9B7E6318),
    oleautomation,
    helpstring("IeXdiX86ExContext3 interface - eXdi Context access for X86 processors 1.1 for NT Windbg - Copyright (C) 2007 Microsoft Corporation"),
    pointer_default(ref),
]
interface IeXdiX86ExContext3 : IUnknown
{


/*++

Routine Name:

    GetContext

Routine Description:

    Read Context - Read a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be read only 

Argument(s):

    pContext        - Return context (CPU dependant structure). 
                        Note: The context is also passed in to indicate only the RegGroupSelection (which reg groups are read)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT GetContext 
(
    [in] DWORD dwProcessorNumber,
    [in, out] PCONTEXT_X86_EX pContext
);


/*++

Routine Name:

    SetContext

Routine Description:

    Write Context - Write a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be written only 

Argument(s):

    Context        - Passes context (CPU dependant structure). 
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT SetContext 
(
    [in] DWORD dwProcessorNumber,
    [in] CONTEXT_X86_EX Context
);


}; // interface IeXdiX86ExContext


const DWORD EXDI_ARM_MAX_BREAKPOINTS = 8;
const DWORD EXDI_ARM_MAX_WATCHPOINTS = 1;
const DWORD EXDI_ARM_MAX_NEON_FP_REGISTERS = 32;

typedef
    struct _CONTEXT_ARM4
    {
        struct 
        {
            BOOL fControlRegs;
            BOOL fIntegerRegs;
            BOOL fFloatingPointRegs;
            BOOL fDebugRegs;
        } RegGroupSelection;

        // Control registers (used if RegGroupSelection.fControlRegs is TRUE)
        DWORD   Sp;
        DWORD   Lr;
        DWORD   Pc;
        DWORD   Psr;
        
        // Integer registers (used if RegGroupSelection.fIntegerRegs is TRUE)
        DWORD   R0;
        DWORD   R1;
        DWORD   R2;
        DWORD   R3;
        DWORD   R4;
        DWORD   R5;
        DWORD   R6;
        DWORD   R7;
        DWORD   R8;
        DWORD   R9;
        DWORD   R10;
        DWORD   R11;
        DWORD   R12;
        
        // Floating point registers (used if RegGroupSelection.fFloatingPointRegs is TRUE)
        DWORD   Fpscr;  // floating point status register
        DWORD64 D[EXDI_ARM_MAX_NEON_FP_REGISTERS];

        // Debug registers (used if RegGroupSelection.fDebugRegs is TRUE)
        DWORD Bvr[EXDI_ARM_MAX_BREAKPOINTS];
        DWORD Bcr[EXDI_ARM_MAX_BREAKPOINTS];
        DWORD Wvr[EXDI_ARM_MAX_WATCHPOINTS];
        DWORD Wcr[EXDI_ARM_MAX_WATCHPOINTS];
        
    } CONTEXT_ARM4, *PCONTEXT_ARM4;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiARM4Context
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


// ARM4 context access interface (used for ARM/NT KD)

[
    object,
    uuid(25A27A99-C6F7-4A27-8749-FA7EA638ADB5),
    oleautomation,
    helpstring("IeXdiARM4Context interface - eXdi Context access for ARM/NT kernel debugger - Copyright (C) 1999-2001 Microsoft Corporation"),
    pointer_default(ref)
]
interface IeXdiARM4Context3 : IUnknown
{


/*++

Routine Name:

    GetContext

Routine Description:

    Read Context - Read a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be read only 

Argument(s):

    pContext        - Return context (CPU dependant structure). 
                        Note: The context is also passed in to indicate only the RegGroupSelection (which reg groups are read)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT GetContext 
(
    [in] DWORD dwProcessorNumber,
    [in, out] PCONTEXT_ARM4 pContext
);


/*++

Routine Name:

    SetContext

Routine Description:

    Write Context - Write a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be written only 

Argument(s):

    Context        - Passes context (CPU dependant structure). 
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT SetContext 
(
    [in] DWORD dwProcessorNumber,
    [in] CONTEXT_ARM4 Context
);


}; // interface IeXdiARM4Context


const DWORD ARMV8ARCH64_MAX_BREAKPOINTS = 8;
const DWORD ARMV8ARCH64_MAX_WATCHPOINTS = 2;
const DWORD ARMV8ARCH64_MAX_INTERGER_REGISTERS = 29;
const DWORD ARMV8ARCH64_MAX_NEON_FP_REGISTERS = 32;

typedef 
    struct _NEON128_REG
    {
        DWORD Reg0;
        DWORD Reg1;
        DWORD Reg2;
        DWORD Reg3;
    } NEON128_REG;

typedef
    struct _CONTEXT_ARMV8ARCH64
    {
        struct 
        {
            BOOL fControlRegs;
            BOOL fIntegerRegs;
            BOOL fFloatingPointRegs;
            BOOL fDebugRegs;
        } RegGroupSelection;

        // Control registers (used if RegGroupSelection.fControlRegs is TRUE)
        DWORD64   Sp;
        DWORD64   Pc;
        DWORD64   Psr;
        
        // Integer registers (used if RegGroupSelection.fIntegerRegs is TRUE)
        DWORD64   X[ARMV8ARCH64_MAX_INTERGER_REGISTERS];
        DWORD64   Fp;
        DWORD64   Lr;
        
        // Floating point registers (used if RegGroupSelection.fFloatingPointRegs is TRUE)
        DWORD   Fpcr;  // floating point control register
        DWORD   Fpsr;  // floating point status register
        NEON128_REG V[ARMV8ARCH64_MAX_NEON_FP_REGISTERS];

        // Debug registers (used if RegGroupSelection.fDebugRegs is TRUE)
        DWORD64 Bvr[ARMV8ARCH64_MAX_BREAKPOINTS];
        DWORD Bcr[ARMV8ARCH64_MAX_BREAKPOINTS];
        DWORD64 Wvr[ARMV8ARCH64_MAX_WATCHPOINTS];
        DWORD Wcr[ARMV8ARCH64_MAX_WATCHPOINTS];
        
    } CONTEXT_ARMV8ARCH64, *PCONTEXT_ARMV8ARCH64;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiArmV8Arch64Context
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


// ARMV8ARCH64 context access interface (used for 64-bit ARM KD)

[
    object,
    uuid(2146BE85-7866-4309-B973-F9650D1AA886),
    oleautomation,
    helpstring("IeXdiArmV8Arch64Context interface - eXdi Context access for ARMv8 (64-bit) kernel debugger - Copyright (C) 1999-2013 Microsoft Corporation"),
    pointer_default(ref)
]
interface IeXdiArmV8Arch64Context3 : IUnknown
{


/*++

Routine Name:

    GetContext

Routine Description:

    Read Context - Read a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be read only 

Argument(s):

    pContext        - Return context (CPU dependant structure). 
                        Note: The context is also passed in to indicate only the RegGroupSelection (which reg groups are read)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadRegWhileRunning
        EXDI_E_NOTIMPL:                  Not implemented
        EXDI_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI_E_INVALIDARG:               One or more arguments are invalid
        EXDI_E_ABORT:                    Operation aborted
        EXDI_E_FAIL:                     Unspecified failure
        EXDI_E_COMMUNICATION:            Communication error between host driver and target
        EXDI_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT GetContext 
(
    [in] DWORD dwProcessorNumber,
    [in, out] PCONTEXT_ARMV8ARCH64 pContext
);


/*++

Routine Name:

    SetContext

Routine Description:

    Write Context - Write a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be written only 

Argument(s):

    Context        - Passes context (CPU dependant structure). 
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteRegWhileRunning
        EXDI_E_NOTIMPL:                  Not implemented
        EXDI_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI_E_INVALIDARG:               One or more arguments are invalid
        EXDI_E_ABORT:                    Operation aborted
        EXDI_E_FAIL:                     Unspecified failure
        EXDI_E_COMMUNICATION:            Communication error between host driver and target
        EXDI_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT SetContext 
(
    [in] DWORD dwProcessorNumber,
    [in] CONTEXT_ARMV8ARCH64 Context
);


}; // interface IeXdiArmV8Arch64Context


cpp_quote("// The following constants are bit definitions for the ModeFlags value in CONTEXT_X86_64.")
cpp_quote("// They are provided to allow debuggers to correctly disassemble instructions based on")
cpp_quote("// the current operating mode of the processor.")

cpp_quote("#define X86_64_MODE_D     (0x0001) // D bit from the current CS selector")
cpp_quote("#define X86_64_MODE_L     (0x0002) // L bit (long mode) from the current CS selector")
cpp_quote("#define X86_64_MODE_LME   (0x0004) // LME bit (lomg mode enable) from extended feature MSR")
cpp_quote("#define X86_64_MODE_REX   (0x0008) // REX bit (register extension) from extended feature MSR")

typedef 
    struct _SEG64_DESC_INFO
    {
        DWORD64 SegBase;
        DWORD64 SegLimit;
        DWORD   SegFlags;
    } SEG64_DESC_INFO;

typedef 
    struct _SSE_REG
    {
        DWORD Reg0;
        DWORD Reg1;
        DWORD Reg2;
        DWORD Reg3;
    } SSE_REG;

#define NUM_SSE_REGS    16

typedef
    struct _CONTEXT_X86_64
    {
        struct 
        {
            BOOL fSegmentRegs;
            BOOL fControlRegs;
            BOOL fIntegerRegs;
            BOOL fFloatingPointRegs;
            BOOL fDebugRegs;
            BOOL fSegmentDescriptors;
            BOOL fSSERegisters;
            BOOL fSystemRegisters;
        }       RegGroupSelection;  // These flags are used to select groups of registers only 
                                    // (instead of the totality) for reading or writing.
        // both Segment & Control registers (used if either RegGroupSelection.fSegmentRegs or
        //  RegGroupSelection.fControlRegs is TRUE).
        DWORD   SegCs;
        DWORD   SegSs;        
        // Segment registers (used if RegGroupSelection.fSegmentRegs is TRUE).
        //  except CS and SS which are in "Segment and Control" - see above
        DWORD   SegGs;
        DWORD   SegFs;
        DWORD   SegEs;
        DWORD   SegDs;
        // Mode flags define the current processor mode (16/32/64 bit)
        DWORD64   ModeFlags;
        // Control registers (used if RegGroupSelection.fControlRegs is TRUE).
        //  except CS and SS which are in "Segment and Control" - see above
        DWORD64   EFlags;
        DWORD64   Rbp;
        DWORD64   Rip;
        DWORD64   Rsp;
        // Integer registers (used if RegGroupSelection.fIntegerRegs is TRUE).
        DWORD64   Rax;
        DWORD64   Rbx;
        DWORD64   Rcx;
        DWORD64   Rdx;
        DWORD64   Rsi;
        DWORD64   Rdi;
        DWORD64   R8;
        DWORD64   R9;
        DWORD64   R10;
        DWORD64   R11;
        DWORD64   R12;
        DWORD64   R13;
        DWORD64   R14;
        DWORD64   R15;
        // Floating point registers (used if RegGroupSelection.fFloatingPointRegs is TRUE).
        DWORD   ControlWord;
        DWORD   StatusWord;
        DWORD   TagWord;
        DWORD   ErrorOffset;
        DWORD   ErrorSelector;
        DWORD   DataOffset;
        DWORD   DataSelector;
        BYTE    RegisterArea [SIZE_OF_80387_REGISTERS_IN_BYTES];
        // Debug registers (used if RegGroupSelection.fDebugRegs is TRUE)
        DWORD64   Dr0;
        DWORD64   Dr1;
        DWORD64   Dr2;
        DWORD64   Dr3;
        DWORD64   Dr6;
        DWORD64   Dr7;
        // Descriptors and base registers (used if RegGroupSelection.fSegmentDescriptors is TRUE)
        SEG64_DESC_INFO DescriptorCs;
        SEG64_DESC_INFO DescriptorSs;
        SEG64_DESC_INFO DescriptorGs;
        SEG64_DESC_INFO DescriptorFs;
        SEG64_DESC_INFO DescriptorEs;
        SEG64_DESC_INFO DescriptorDs;
        DWORD64 IDTBase;
        DWORD64 IDTLimit;
        DWORD64 GDTBase;
        DWORD64 GDTLimit;
        DWORD SelLDT;
        SEG64_DESC_INFO SegLDT;
        DWORD SelTSS;
        SEG64_DESC_INFO SegTSS;
        // System registers (used if RegGroupSelection.fSystemRegisters is TRUE)
        DWORD64 RegCr0;
        DWORD64 RegCr2;
        DWORD64 RegCr3;
        DWORD64 RegCr4;
        DWORD64 RegCr8;         // Cr8 - Task priority register.
        // SSE registers (used if RegGroupSelection.fSSERegisters is TRUE)
        DWORD RegMXCSR;
        SSE_REG RegSSE[NUM_SSE_REGS];
    } CONTEXT_X86_64, *PCONTEXT_X86_64;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiX86_64Context
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


// X86_64 context access interface

[
    object,
    uuid(3A5BF3FF-8CDA-4789-8323-BE04A970D006),
    oleautomation,
    helpstring("IeXdiX86_64Context interface - eXdi Context access for 64 Bit X86 processors 1.0 for Platform Builder 3.0 debugger - Microsoft 1999"),
    pointer_default(ref),
]
interface IeXdiX86_64Context3 : IUnknown
{


/*++

Routine Name:

    GetContext

Routine Description:

    Read Context - Read a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be read only 

Argument(s):

    pContext        - Return context (CPU dependant structure). 
                        Note: The context is also passed in to indicate only the RegGroupSelection (which reg groups are read)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURENTTHREAD:    Cannot proceed immediately because resource is already used by concurent thread.

--*/

HRESULT GetContext 
(
    [in] DWORD dwProcessorNumber,
    [in, out] PCONTEXT_X86_64 pContext
);


/*++

Routine Name:

    SetContext

Routine Description:

    Write Context - Write a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be written only 

Argument(s):

    pContext        - Return context (CPU dependant structure). 
                        Note: The context is also passed in to indicate only the RegGroupSelection (which reg groups are read)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURENTTHREAD:    Cannot proceed immediately because resource is already used by concurent thread.

--*/

HRESULT SetContext 
(
    [in] DWORD dwProcessorNumber,
    [in] CONTEXT_X86_64 Context
);


}; // interface IeXdiX86_64Context


typedef 
    struct _IA64_FLOAT128
    {
        DWORD64 Low;
        DWORD64 High;
    } IA64_FLOAT128;

typedef
    struct _EXDI_CONTEXT_IA64
    {
        struct 
        {
            BOOL fIntegerRegs;
            BOOL fBranchRegs;
            BOOL fLowFloatRegs;
            BOOL fHighFloatRegs;
            BOOL fDebugRegs;
            BOOL fControlRegs;
            BOOL fSystemRegs;
        } RegGroupSelection;

        //
        // fIntegerRegs.
        //

        DWORD64 IntR1;
        DWORD64 IntR2;
        DWORD64 IntR3;
        DWORD64 IntR4;
        DWORD64 IntR5;
        DWORD64 IntR6;
        DWORD64 IntR7;
        DWORD64 IntR8;
        DWORD64 IntR9;
        DWORD64 IntR10;
        DWORD64 IntR11;
        DWORD64 IntR12;
        DWORD64 IntR13;
        DWORD64 IntR14;
        DWORD64 IntR15;
        DWORD64 IntR16;
        DWORD64 IntR17;
        DWORD64 IntR18;
        DWORD64 IntR19;
        DWORD64 IntR20;
        DWORD64 IntR21;
        DWORD64 IntR22;
        DWORD64 IntR23;
        DWORD64 IntR24;
        DWORD64 IntR25;
        DWORD64 IntR26;
        DWORD64 IntR27;
        DWORD64 IntR28;
        DWORD64 IntR29;
        DWORD64 IntR30;
        DWORD64 IntR31;

        DWORD64 IntNats;

        //
        // fBranchRegs.
        //
        
        DWORD64 Preds;

        DWORD64 Br0;
        DWORD64 Br1;
        DWORD64 Br2;
        DWORD64 Br3;
        DWORD64 Br4;
        DWORD64 Br5;
        DWORD64 Br6;
        DWORD64 Br7;

        //
        // fLowFloatRegs or fHighFloatRegs.
        //
        
        DWORD64 StFPSR;
        
        //
        // fLowFloatRegs.
        //
        
        IA64_FLOAT128 FltF2;
        IA64_FLOAT128 FltF3;
        IA64_FLOAT128 FltF4;
        IA64_FLOAT128 FltF5;
        IA64_FLOAT128 FltF6;
        IA64_FLOAT128 FltF7;
        IA64_FLOAT128 FltF8;
        IA64_FLOAT128 FltF9;
        IA64_FLOAT128 FltF10;
        IA64_FLOAT128 FltF11;
        IA64_FLOAT128 FltF12;
        IA64_FLOAT128 FltF13;
        IA64_FLOAT128 FltF14;
        IA64_FLOAT128 FltF15;

        //
        // fHighFloatRegs.
        //
        
        IA64_FLOAT128 FltF16;
        IA64_FLOAT128 FltF17;
        IA64_FLOAT128 FltF18;
        IA64_FLOAT128 FltF19;
        IA64_FLOAT128 FltF20;
        IA64_FLOAT128 FltF21;
        IA64_FLOAT128 FltF22;
        IA64_FLOAT128 FltF23;
        IA64_FLOAT128 FltF24;
        IA64_FLOAT128 FltF25;
        IA64_FLOAT128 FltF26;
        IA64_FLOAT128 FltF27;
        IA64_FLOAT128 FltF28;
        IA64_FLOAT128 FltF29;
        IA64_FLOAT128 FltF30;
        IA64_FLOAT128 FltF31;
        IA64_FLOAT128 FltF32;
        IA64_FLOAT128 FltF33;
        IA64_FLOAT128 FltF34;
        IA64_FLOAT128 FltF35;
        IA64_FLOAT128 FltF36;
        IA64_FLOAT128 FltF37;
        IA64_FLOAT128 FltF38;
        IA64_FLOAT128 FltF39;
        IA64_FLOAT128 FltF40;
        IA64_FLOAT128 FltF41;
        IA64_FLOAT128 FltF42;
        IA64_FLOAT128 FltF43;
        IA64_FLOAT128 FltF44;
        IA64_FLOAT128 FltF45;
        IA64_FLOAT128 FltF46;
        IA64_FLOAT128 FltF47;
        IA64_FLOAT128 FltF48;
        IA64_FLOAT128 FltF49;
        IA64_FLOAT128 FltF50;
        IA64_FLOAT128 FltF51;
        IA64_FLOAT128 FltF52;
        IA64_FLOAT128 FltF53;
        IA64_FLOAT128 FltF54;
        IA64_FLOAT128 FltF55;
        IA64_FLOAT128 FltF56;
        IA64_FLOAT128 FltF57;
        IA64_FLOAT128 FltF58;
        IA64_FLOAT128 FltF59;
        IA64_FLOAT128 FltF60;
        IA64_FLOAT128 FltF61;
        IA64_FLOAT128 FltF62;
        IA64_FLOAT128 FltF63;
        IA64_FLOAT128 FltF64;
        IA64_FLOAT128 FltF65;
        IA64_FLOAT128 FltF66;
        IA64_FLOAT128 FltF67;
        IA64_FLOAT128 FltF68;
        IA64_FLOAT128 FltF69;
        IA64_FLOAT128 FltF70;
        IA64_FLOAT128 FltF71;
        IA64_FLOAT128 FltF72;
        IA64_FLOAT128 FltF73;
        IA64_FLOAT128 FltF74;
        IA64_FLOAT128 FltF75;
        IA64_FLOAT128 FltF76;
        IA64_FLOAT128 FltF77;
        IA64_FLOAT128 FltF78;
        IA64_FLOAT128 FltF79;
        IA64_FLOAT128 FltF80;
        IA64_FLOAT128 FltF81;
        IA64_FLOAT128 FltF82;
        IA64_FLOAT128 FltF83;
        IA64_FLOAT128 FltF84;
        IA64_FLOAT128 FltF85;
        IA64_FLOAT128 FltF86;
        IA64_FLOAT128 FltF87;
        IA64_FLOAT128 FltF88;
        IA64_FLOAT128 FltF89;
        IA64_FLOAT128 FltF90;
        IA64_FLOAT128 FltF91;
        IA64_FLOAT128 FltF92;
        IA64_FLOAT128 FltF93;
        IA64_FLOAT128 FltF94;
        IA64_FLOAT128 FltF95;
        IA64_FLOAT128 FltF96;
        IA64_FLOAT128 FltF97;
        IA64_FLOAT128 FltF98;
        IA64_FLOAT128 FltF99;
        IA64_FLOAT128 FltF100;
        IA64_FLOAT128 FltF101;
        IA64_FLOAT128 FltF102;
        IA64_FLOAT128 FltF103;
        IA64_FLOAT128 FltF104;
        IA64_FLOAT128 FltF105;
        IA64_FLOAT128 FltF106;
        IA64_FLOAT128 FltF107;
        IA64_FLOAT128 FltF108;
        IA64_FLOAT128 FltF109;
        IA64_FLOAT128 FltF110;
        IA64_FLOAT128 FltF111;
        IA64_FLOAT128 FltF112;
        IA64_FLOAT128 FltF113;
        IA64_FLOAT128 FltF114;
        IA64_FLOAT128 FltF115;
        IA64_FLOAT128 FltF116;
        IA64_FLOAT128 FltF117;
        IA64_FLOAT128 FltF118;
        IA64_FLOAT128 FltF119;
        IA64_FLOAT128 FltF120;
        IA64_FLOAT128 FltF121;
        IA64_FLOAT128 FltF122;
        IA64_FLOAT128 FltF123;
        IA64_FLOAT128 FltF124;
        IA64_FLOAT128 FltF125;
        IA64_FLOAT128 FltF126;
        IA64_FLOAT128 FltF127;

        //
        // fDebugRegs.
        //
        
        DWORD64 DbI0;
        DWORD64 DbI1;
        DWORD64 DbI2;
        DWORD64 DbI3;
        DWORD64 DbI4;
        DWORD64 DbI5;
        DWORD64 DbI6;
        DWORD64 DbI7;

        DWORD64 DbD0;
        DWORD64 DbD1;
        DWORD64 DbD2;
        DWORD64 DbD3;
        DWORD64 DbD4;
        DWORD64 DbD5;
        DWORD64 DbD6;
        DWORD64 DbD7;

        //
        // fControlRegs.
        //

        // Application registers.
        DWORD64 ApUNAT;
        DWORD64 ApLC;
        DWORD64 ApEC;
        DWORD64 ApCCV;
        DWORD64 ApDCR;

        // Register stack registers.
        DWORD64 RsPFS;
        DWORD64 RsBSP;
        DWORD64 RsBSPSTORE;
        DWORD64 RsRSC;
        DWORD64 RsRNAT;

        // Trap status information.
        DWORD64 StIPSR;
        DWORD64 StIIP;
        DWORD64 StIFS;

        // iA32 related control registers.
        DWORD64 StFCR;
        DWORD64 Eflag;
        DWORD64 SegCSD;
        DWORD64 SegSSD;
        DWORD64 Cflag;
        DWORD64 StFSR;
        DWORD64 StFIR;
        DWORD64 StFDR;

        //
        // fSystemRegs.
        //
        
        // Performance monitor registers.
        DWORD64 PfC0;
        DWORD64 PfC1;
        DWORD64 PfC2;
        DWORD64 PfC3;
        DWORD64 PfC4;
        DWORD64 PfC5;
        DWORD64 PfC6;
        DWORD64 PfC7;
        DWORD64 PfD0;
        DWORD64 PfD1;
        DWORD64 PfD2;
        DWORD64 PfD3;
        DWORD64 PfD4;
        DWORD64 PfD5;
        DWORD64 PfD6;
        DWORD64 PfD7;

        // Kernel bank shadow (hidden) registers.
        DWORD64 IntH16;
        DWORD64 IntH17;
        DWORD64 IntH18;
        DWORD64 IntH19;
        DWORD64 IntH20;
        DWORD64 IntH21;
        DWORD64 IntH22;
        DWORD64 IntH23;
        DWORD64 IntH24;
        DWORD64 IntH25;
        DWORD64 IntH26;
        DWORD64 IntH27;
        DWORD64 IntH28;
        DWORD64 IntH29;
        DWORD64 IntH30;
        DWORD64 IntH31;

        // CPUID Registers - AR.
        DWORD64 ApCPUID0;
        DWORD64 ApCPUID1;
        DWORD64 ApCPUID2;
        DWORD64 ApCPUID3;
        DWORD64 ApCPUID4;
        DWORD64 ApCPUID5;
        DWORD64 ApCPUID6;
        DWORD64 ApCPUID7;

        // Kernel Registers - AR.
        DWORD64 ApKR0;
        DWORD64 ApKR1;
        DWORD64 ApKR2;
        DWORD64 ApKR3;
        DWORD64 ApKR4;
        DWORD64 ApKR5;
        DWORD64 ApKR6;
        DWORD64 ApKR7;

        // Interval time counter.
        DWORD64 ApITC;

        // Global control registers.
        DWORD64 ApITM;
        DWORD64 ApIVA;
        DWORD64 ApPTA;
        DWORD64 ApGPTA;

        // Interruption information.
        DWORD64 StISR;
        DWORD64 StIFA;
        DWORD64 StITIR;
        DWORD64 StIIPA;
        DWORD64 StIIM;
        DWORD64 StIHA;

        // External Interrupt control registers (SAPIC).
        DWORD64 SaLID;
        DWORD64 SaIVR;
        DWORD64 SaTPR;
        DWORD64 SaEOI;
        DWORD64 SaIRR0;
        DWORD64 SaIRR1;
        DWORD64 SaIRR2;
        DWORD64 SaIRR3;
        DWORD64 SaITV;
        DWORD64 SaPMV;
        DWORD64 SaCMCV;
        DWORD64 SaLRR0;
        DWORD64 SaLRR1;

        // Region registers.
        DWORD64 Rr0;
        DWORD64 Rr1;
        DWORD64 Rr2;
        DWORD64 Rr3;
        DWORD64 Rr4;
        DWORD64 Rr5;
        DWORD64 Rr6;
        DWORD64 Rr7;

        // Protection Key registers.
        DWORD64 Pkr0;
        DWORD64 Pkr1;
        DWORD64 Pkr2;
        DWORD64 Pkr3;
        DWORD64 Pkr4;
        DWORD64 Pkr5;
        DWORD64 Pkr6;
        DWORD64 Pkr7;
        DWORD64 Pkr8;
        DWORD64 Pkr9;
        DWORD64 Pkr10;
        DWORD64 Pkr11;
        DWORD64 Pkr12;
        DWORD64 Pkr13;
        DWORD64 Pkr14;
        DWORD64 Pkr15;

        // Translation Lookaside buffers.
        DWORD64 TrI0;
        DWORD64 TrI1;
        DWORD64 TrI2;
        DWORD64 TrI3;
        DWORD64 TrI4;
        DWORD64 TrI5;
        DWORD64 TrI6;
        DWORD64 TrI7;
        DWORD64 TrD0;
        DWORD64 TrD1;
        DWORD64 TrD2;
        DWORD64 TrD3;
        DWORD64 TrD4;
        DWORD64 TrD5;
        DWORD64 TrD6;
        DWORD64 TrD7;

        // Machine Specific Registers.
        DWORD64 SrMSR0;
        DWORD64 SrMSR1;
        DWORD64 SrMSR2;
        DWORD64 SrMSR3;
        DWORD64 SrMSR4;
        DWORD64 SrMSR5;
        DWORD64 SrMSR6;
        DWORD64 SrMSR7;
    } EXDI_CONTEXT_IA64, *PEXDI_CONTEXT_IA64;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiIA64Context
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


// IA64 context access interface

[
    object,
    uuid(24C6A990-780C-428E-BE5B-E27E2CAEA05A),
    oleautomation,
    helpstring("IeXdiIA64Context3 interface - eXdi Context access for IA64 processors 1.0 for Platform Builder 3.0 debugger - Microsoft 2007"),
    pointer_default(ref),
]
interface IeXdiIA64Context3 : IUnknown
{


/*++

Routine Name:

    GetContext

Routine Description:

    Read Context - Read a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be read only 

Argument(s):

    pContext        - Return context (CPU dependant structure). 
                        Note: The context is also passed in to indicate only the RegGroupSelection (which reg groups are read)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURENTTHREAD:    Cannot proceed immediately because resource is already used by concurent thread.

--*/

HRESULT GetContext 
(
    [in] DWORD dwProcessorNumber,
    [in, out] PEXDI_CONTEXT_IA64 pContext
);


/*++

Routine Name:

    SetContext

Routine Description:

    Write Context - Write a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be written only 

Argument(s):

    pContext        - Return context (CPU dependant structure). 
                        Note: The context is also passed in to indicate only the RegGroupSelection (which reg groups are read)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURENTTHREAD:    Cannot proceed immediately because resource is already used by concurent thread.

--*/

HRESULT SetContext 
(
    [in] DWORD dwProcessorNumber,
    [in] EXDI_CONTEXT_IA64 Context
);


}; // interface IeXdiIA64Context

typedef
    struct _EXDI_CONTEXT_EBC
    {
        struct 
        {
            BOOL fGeneralRegs;
            BOOL fDedicatedRegs;
        } RegGroupSelection;

        //
        // fGeneralRegs.
        //

        DWORD64 R0;
        DWORD64 R1;
        DWORD64 R2;
        DWORD64 R3;
        DWORD64 R4;
        DWORD64 R5;
        DWORD64 R6;
        DWORD64 R7;

        //
        // fDedicatedRegs.
        //

        DWORD64 Flags;
        DWORD64 IP;
        DWORD64 D2;
        DWORD64 D3;
        DWORD64 D4;
        DWORD64 D5;
        DWORD64 D6;
        DWORD64 D7;

    } EXDI_CONTEXT_EBC, *PEXDI_CONTEXT_EBC;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiEBCContext
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid(6C4E5523-3AC1-4014-B454-E54E180ABD8E),
    oleautomation,
    helpstring("IeXdiEBCContext interface - eXdi Context access for EFI byte code virtual machines 1.0 for Platform Builder 3.0 debugger - Microsoft 2002"),
    pointer_default(ref)
]
interface IeXdiEBCContext3 : IUnknown
{


/*++

Routine Name:

    GetContext

Routine Description:

    Read Context - Read a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be read only 

Argument(s):

    pContext        - Return context (CPU dependant structure). 
                        Note: The context is also passed in to indicate only the RegGroupSelection (which reg groups are read)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fReadRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURENTTHREAD:    Cannot proceed immediately because resource is already used by concurent thread.

--*/

HRESULT GetContext 
(
        [in] DWORD dwProcessorNumber,
        [in, out] PEXDI_CONTEXT_EBC pContext
);


/*++

Routine Name:

    SetContext

Routine Description:

    Write Context - Write a set of CPU / Co-Proc registers that define the state of the target
                    The CONTEXT.RegGroupSelection bitfield allow to select which group of register need to be written only 

Argument(s):

    pContext        - Return context (CPU dependant structure). 
                        Note: The context is also passed in to indicate only the RegGroupSelection (which reg groups are read)
    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_CANNOTWHILETGTRUNNING     Cannot proceed while target running. Must halt the target first.
                                            Note: this error is generated only if the probe / target does not support this operation "on the fly". 
                                            see DEBUG_ACCESS_CAPABILITIES_STRUCT.fWriteRegWhileRunning
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURENTTHREAD:    Cannot proceed immediately because resource is already used by concurent thread.

--*/

HRESULT SetContext 
(
        [in] DWORD dwProcessorNumber,
        [in] EXDI_CONTEXT_EBC Context
);


}; // interface IeXdiEBCContext

/////////////////////////////////////////////////////////////////////////////
// Notify Run state change
/////////////////////////////////////////////////////////////////////////////

[
    object,
    uuid(CEC95378-3797-4079-9C70-A45AB2F85278),
    oleautomation,
    helpstring("IeXdiClientNotifyRunChg interface - eXdi Notify Run State Changes 1.0 for Platform Builder 3.0 debugger - Copyright (C) 1999-2007 Microsoft Corporation"),
    pointer_default(ref),
]
interface IeXdiClientNotifyRunChg3 : IUnknown
{


/*++

Routine Name:

    NotifyRunStateChange

Routine Description:

    Indicate a change in Run state - The debugger can use this function to invalidate its internal cache.
    This function should be called by the driver only when the target is halted. When the target is running, all memory cache should be invalidated.

Argument(s):

    ersCurrent      - Supplies the current Run Status Type
    ehrCurrent      - Suppliest the current Halt Reason Type (hrNone if Run Status is not Halted)
    CurrentExecAddress - Current program / instruction pointer if Run Status is Halted, undefined otherwise.
    dwExceptionCode - indicate type / source of exception (Code is platform dependant) if Halted due to exception ((rsHalted == ersCurrent) && (hrException == ehrCurrent)), undefined otherwise.

    
Return Value:

    Error status:
        S_OK:                            Function successful
        EXDI3_E_NOTIMPL:                  Not implemented
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target
        EXDI3_E_USEDBYCONCURRENTTHREAD:    Cannot proceed immediately because resource is already used by concurrent thread.

--*/

HRESULT NotifyRunStateChange 
(
    [in] RUN_STATUS_TYPE ersCurrent, 
    [in] HALT_REASON_TYPE ehrCurrent,
    [in] ADDRESS_TYPE CurrentExecAddress,
    [in] DWORD dwExceptionCode,
    [in] DWORD dwProcessorNumber
);


}; // interface IeXdiClientNotifyRunChg

[
    object,
    uuid(2AD8BA47-DE4D-47E2-A922-78E5790A0E0A),
    oleautomation,
    helpstring("IeXdiKeepaliveInterface3 interface - Allows checking whether the RPC connection between the server and the client is still available"),
    pointer_default(ref),
]
interface IeXdiKeepaliveInterface3 : IUnknown
{
    HRESULT IsDebugSessionAlive();
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// IeXdiControlComponentFunctions
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// Control different functionality exposed by the GdServer

typedef enum _ExdiComponentFunctionType
{
    
    exdiComponentSession,   // Exdi component executes a passed in function string
    exdiTargetEntity,       // The target entity (whatever it is GdbServer/T32 API, etc.) executes 
                            // a passed in function string
    exdiUnknown
}
ExdiComponentFunctionType;

[
    object,
    uuid(630e91f3-dfe2-49c8-b274-2843595a4fa6),
    oleautomation,
    helpstring("IeXdiControlComponentFunctions interface - This interface allows executing Exdi-Component or target commands."),
    pointer_default(ref),
]
interface IeXdiControlComponentFunctions : IUnknown
{


/*++

Routine Name:

    ExecuteExdiComponentFunction

Routine Description:

    Execute an Exdi component high level function (like Connect/Close session).

Argument(s):
	function type		- Function to be executed on the exdi component.
	processor 			- Processor number. -1 if the function will be executed on all DbgServer sessions.
	pFunctionToExecute 	- Pointer to the string containing the function type to execute.
    
Return Value:

    Error status:
        S_OK:                             Function successful
        EXDI3_E_NOTIMPL:                  Not implemented for the current Exdi implementation
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target

--*/

HRESULT ExecuteExdiComponentFunction
(
    [in] ExdiComponentFunctionType type,
    [in] DWORD dwProcessorNumber,
	[in] LPCWSTR pFunctionToExecute
);


/*++

Routine Name:

     ExecuteTargetEntityFunction

Routine Description:

    Pass through a function string to the target entity (ex. GdbServer/T32 API, etc).

Argument(s):
	function type		- Function type component/target to be executed on a particular processor.
	processor 			- Processor number. -1 if the function will be executed on all target entity sessions.
	pFunctionToExecute 	- Pointer to the string containing the function type to execute.
	pFunctionResponseBuffer - Contains the response buffer.
    
Return Value:

    Error status:
        S_OK:                             Function successful
        EXDI3_E_NOTIMPL:                  Not implemented for the current Exdi implementation
        EXDI3_E_OUTOFMEMORY:              Failed to allocate necessary memory
        EXDI3_E_INVALIDARG:               One or more arguments are invalid
        EXDI3_E_ABORT:                    Operation aborted
        EXDI3_E_FAIL:                     Unspecified failure
        EXDI3_E_COMMUNICATION:            Communication error between host driver and target

--*/

HRESULT ExecuteTargetEntityFunction 
(
    [in] ExdiComponentFunctionType type,
    [in] DWORD dwProcessorNumber,
	[in] LPCWSTR pFunctionToExecute,
    [out] SAFEARRAY(BYTE) * pFunctionResponseBuffer
);


}; // interface IeXdiControlComponentFunctions

